package co.petrin.ekristijan.security
import de.mkammerer.argon2.Argon2
import io.vertx.ext.auth.User
import io.vertx.ext.auth.authorization.PermissionBasedAuthorization
import io.vertx.ext.auth.jwt.JWTAuth
import io.vertx.kotlin.core.json.jsonObjectOf
import io.vertx.kotlin.coroutines.await
import io.vertx.kotlin.ext.auth.jwtOptionsOf

/*
    Password resets work like this: users can request a password reset. An email message will be sent to the user
    containing a link with an embedded JWT. This JWT will contain the users' email address as its subject and
    "reset-password" will be among its permissions.

    The system will not actually send emails to addresses in our database to prevent the app from spamming people, but
    from this app's security perspective we might as well generate those reset tokens - they will match no user in the
    database anyway.

    When a user submits a password reset request using this JWT, it will be decoded and verified. Its creation timestamp
    will be taken as its uniqueness identifier (to prevent token reuse). User will also send their new password so
    those can be hashed and stored into the database.
 */

val RESET_PASSWORD_SCOPE = "reset-token"

/**
 * A password reset payload, encoded as JWT. Checking the JWT signature ensures the payload was generated by us.
 * @property teacherEmail email of the teacher whose password we should reset
 * @property uniqueIdentifier A unique identifier of the token, allowing them to be used only once
 */
data class PasswordReset(val teacherEmail: String, val uniqueIdentifier: Long)

/** Generates a new password reset token */
fun generatePasswordResetToken(teacherEmail: String, expiresInMinutes: Int, jwt: JWTAuth): String {
    val props = jwtOptionsOf(
        subject = teacherEmail,
        expiresInMinutes = expiresInMinutes
    )
    return jwt.generateToken(jsonObjectOf(
        "scope" to RESET_PASSWORD_SCOPE
    ), props)
}

/**
 * Decodes a JWT password reset token.
 * Throws an IllegalStateException if the signature verification had failed!
 */
fun decodePasswordResetFromUser(user: User): PasswordReset {
    val uniqueToken = user.attributes().getLong(IAT_UNIQUE_PARAM)
    return PasswordReset(teacherEmail = user.subject(), uniqueIdentifier = uniqueToken)
}

/** Hashes a password with some sane parameters */
fun hashPassword(password: String, passEncoder: Argon2) =
    passEncoder.hash(10, 65536, 1, password)